<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>icy_perimeter</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
</head>
<body>
<h2 id="analysis">Analysis</h2>
<p>This problem is to compute the area and perimeter of all connected
components. Area is easy, it just counts the number of cells in the
connected component. The perimeter is dectected as follows:</p>
<ul>
<li>The cell edge next to the boarder</li>
<li>The cell edge next to empty space</li>
</ul>
<h2 id="code">Code</h2>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int N;
vector&lt;vector&lt;char&gt;&gt; grid;
vector&lt;vector&lt;bool&gt;&gt; visited;
vector&lt;vector&lt;int&gt;&gt; D = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

int area, perimeter;

void dfs(int r, int c) {
    // edge next to boarder
    if (r &lt; 0 || r &gt;= N || c &lt; 0 || c &gt;= N) {
        perimeter++;
        return;
    }
    if (visited[r][c]) return;
    // edge next to empty space
    if (grid[r][c] == &#39;.&#39;) {
        perimeter++;
        return;
    }
    visited[r][c] = true;
    area++;
    for (int k = 0; k &lt; 4; ++k) {
        dfs(r + D[k][0], c + D[k][1]);
    }
}

int main() {
    freopen(&quot;perimeter.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;perimeter.out&quot;, &quot;w&quot;, stdout);

    cin &gt;&gt; N;
    grid.resize(N);
    grid.assign(N, vector&lt;char&gt;(N));

    visited.resize(N);
    visited.assign(N, vector&lt;bool&gt;(N));

    for (int i = 0; i &lt; N; ++i) {
        for (int j = 0; j &lt; N; ++j) {
            cin &gt;&gt; grid[i][j];
        }
    }

    int area_output = 0, perimeter_output = 0;
    for (int i = 0; i &lt; N; ++i) {
        for (int j = 0; j &lt; N; ++j) {
            if (!visited[i][j] &amp;&amp; grid[i][j] == &#39;#&#39;) {
                area = perimeter = 0;
                dfs(i, j);
                if (area &gt; area_output) {
                    area_output = area;
                    perimeter_output = perimeter;
                } else if (area == area_output) {
                    perimeter_output = min(perimeter_output, perimeter);
                }
            }
        }
    }

    cout &lt;&lt; area_output &lt;&lt; &quot; &quot; &lt;&lt; perimeter_output &lt;&lt; &quot;\n&quot;;
    return 0;
}</code></pre>
</body>
</html>
